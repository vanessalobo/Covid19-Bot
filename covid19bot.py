# -*- coding: utf-8 -*-
"""Covid19Bot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/189HzOSEfJUQRpT-87Al47khyUKydiLJa
"""

import tweepy
import time
from datetime import date
import datetime
# Declaring API keys and Consumer Keys
# Generate your keys and replace with below placeholders
consumer_key = "C1fYDFlthopIA2gJclwxGpQL9"
consumer_secret = "AOUncdErnCGjUH3pbIwKjGVaLMo3Yawqnt3XzykxmNZ5VjaE2V"
access_token = "1386034465818902528-ZbVOXnCLTTZ73FQkRcnuvpwAFxnlId"
access_token_secret = "ah8QFti6hOKQFQnwlA3hc4TiwnftS8DHjtxi3D8luGj1S"
# Take the keys and authenticate the bot
auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)
api = tweepy.API(auth, wait_on_rate_limit= True)
user=api.me()
print(user.name)

#global vars
FILE_NAME='last_seen_id.txt'
date_since = date.today()
tweet_count = 10


def retrieve_last_seen_id(file_name):
    f_read = open(file_name, 'r')
    for line in f_read:
      last_seen_id = line.split(' ')
    f_read.close()
    return last_seen_id[0].rstrip()


def store_last_seen_id(last_seen_id, file_name):
    f_write = open(file_name, 'w')
    f_write.write(str(last_seen_id))
    f_write.close()
    return



def searchbot(q, mention):


    tweets = tweepy.Cursor(api.search, q, since=date.today(), tweet_mode="extended").items(tweet_count)
    ctr=0
    #print(any(tweets))

    while not any(tweets) and (ctr>-2):
        ctr=ctr-1
        use_time=date.today() + datetime.timedelta(days=ctr)
        tweets = tweepy.Cursor(api.search, q, since=use_time).items(tweet_count)
        print(any(tweets))
    msg=""
    if any(tweets) and ctr<0:
        msg=" Sorry, there are no verified leads from today. However, here are leads from the past 2 days"
    elif not any(tweets):
        msg=" Sorry, there are no recent verified leads for the given requirement. Try putting another location nearby or try in a few hours"

    if ctr<0 or not any(tweets):
        api.update_status('@' + mention.user.screen_name + " " +msg, mention.id)

    if not any(tweets):
        return
    for tweet in tweets:
        api.update_status('@' + mention.user.screen_name + ' https://twitter.com/twitter/statuses/'+ str(tweet.id), mention.id)

def reply_to_tweets():
    print('retrieving and replying to tweets...', flush=True)
    # DEV NOTE: use 1060651988453654528 for testing.
    last_seen_id = retrieve_last_seen_id(FILE_NAME)
    # NOTE: We need to use tweet_mode='extended' below to show
    # all full tweets (with full_text). Without it, long tweets
    # would be cut off.
    mentions = api.mentions_timeline(
                        int(last_seen_id),
                        tweet_mode='extended')
    for mention in reversed(mentions):
        print(str(mention.id) + ' - ' + mention.full_text, flush=True)
        last_seen_id = mention.id
        store_last_seen_id(last_seen_id, FILE_NAME)
        q=mention.full_text
        q=q.lower()
        s=q
        keywords=[]
        keywords=s.split(" ")
        ind=mention.full_text.find(" ")
        q=q[ind+1:]
        q+=" available -need -filter:retweets"
        print(q)
        searchbot(q, mention)


while True:
    reply_to_tweets()
    time.sleep(15)
